generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-1.0.x", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String                     @id @default(cuid())
  email                String?                    @unique
  phone                String?                    @unique
  password             String
  role                 Role                       @default(STUDENT)
  name                 String
  avatar               String?
  isActive             Boolean                    @default(true)
  lastLoginAt          DateTime?
  createdAt            DateTime                   @default(now())
  updatedAt            DateTime                   @updatedAt
  deletedAt            DateTime?
  instituteId          String?
  activeSessionId      String?
  lastSessionInfo      Json?
  passwordResetExpires DateTime?
  passwordResetToken   String?                    @unique
  emailChangeToken     String?                    @unique
  emailVerified        Boolean                    @default(false)
  isApproved           Boolean                    @default(false)
  pendingEmail         String?
  pendingPhone         String?
  verificationToken    String?                    @unique
  activityAudits       ActivityAudit[]
  admissionReviews     AdmissionApplication[]     @relation("AdmissionReviewer")
  aiActivities         AIActivity[]
  attendanceRecords    Attendance[]               @relation("AttendanceTeacher")
  badges               Badge[]                    @relation("UserBadges")
  billing              Billing[]
  chatSessions         ChatSession[]
  examAssignments      ExamEvaluationAssignment[] @relation("ExamAssignmentCreator")
  examEvaluations      ExamEvaluationAssignment[] @relation("ExamEvaluator")
  examSets             ExamSet[]
  drawings             ExamSubmissionDrawing[]
  assignedExams        Exam[]                     @relation("ExamAssigner")
  createdExams         Exam[]                     @relation("ExamCreator")
  exportJobs           ExportJob[]
  managedInstitute     Institute?                 @relation("InstituteSuperUser")
  createdInvoices      Invoice[]                  @relation("InvoiceCreator")
  logs                 Log[]
  notices              Notice[]
  notifications        Notification[]
  collectedPayments    Payment[]                  @relation("PaymentCollector")
  questionBanks        QuestionBank[]
  questions            Question[]
  editedQuestions      Question[]                 @relation("EditedQuestions")
  resultReviews        ResultReview[]             @relation("ResultReviewer")
  studentProfile       StudentProfile?
  teacherProfile       TeacherProfile?
  institute            Institute?                 @relation("InstituteUsers", fields: [instituteId], references: [id])

  @@index([role])
  @@map("users")
}

model Institute {
  id           String     @id @default(cuid())
  name         String
  address      String?
  phone        String?
  email        String?
  website      String?
  logoUrl      String?
  signatureUrl String?
  colorTheme   Json?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  superUserId  String?    @unique
  classes      Class[]
  examHalls    ExamHall[]
  superUser    User?      @relation("InstituteSuperUser", fields: [superUserId], references: [id])
  settings     Settings?
  users        User[]     @relation("InstituteUsers")

  @@map("institutes")
}

model StudentProfile {
  id               String                  @id @default(cuid())
  roll             String
  registrationNo   String                  @unique
  guardianName     String
  guardianPhone    String
  guardianEmail    String?
  address          String?
  dateOfBirth      DateTime?
  bloodGroup       String?
  emergencyContact String?
  createdAt        DateTime                @default(now())
  updatedAt        DateTime                @updatedAt
  userId           String                  @unique
  classId          String
  examSubmissions  ExamSubmission[]
  admissionApp     AdmissionApplication?
  admitCards       AdmitCard[]
  badges           Badge[]                 @relation("StudentBadges")
  examStudentMaps  ExamStudentMap[]
  drawings         ExamSubmissionDrawing[]
  invoices         Invoice[]
  omrSheets        OMRSheet[]
  resultReviews    ResultReview[]
  results          Result[]
  practiceResults  PracticeResult[]
  seatAllocations  SeatAllocation[]
  class            Class                   @relation(fields: [classId], references: [id])
  user             User                    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("student_profiles")
}

model TeacherProfile {
  id            String         @id @default(cuid())
  employeeId    String         @unique
  department    String?
  qualification String?
  joiningDate   DateTime?
  subjects      String[]
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  userId        String         @unique
  questionBanks QuestionBank[] @relation("TeacherQuestionBanks")
  questions     Question[]     @relation("TeacherQuestions")
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("teacher_profiles")
}

model Class {
  id                    String                 @id @default(cuid())
  name                  String
  section               String
  shift                 String?
  subjectGroup          String?
  capacity              Int                    @default(40)
  isActive              Boolean                @default(true)
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  instituteId           String
  admissionApplications AdmissionApplication[]
  attendance            Attendance[]
  institute             Institute              @relation(fields: [instituteId], references: [id])
  exams                 Exam[]
  feeStructures         FeeStructure[]
  questions             Question[]             @relation("ClassQuestions")
  students              StudentProfile[]
  notices               Notice[]               @relation("NoticeToClasses")

  @@unique([name, section, instituteId])
  @@map("classes")
}

model Exam {
  id                    String                     @id @default(cuid())
  name                  String
  description           String?
  date                  DateTime
  startTime             DateTime
  endTime               DateTime
  duration              Int
  type                  ExamType                   @default(OFFLINE)
  totalMarks            Int
  passMarks             Int
  isActive              Boolean                    @default(false)
  allowRetake           Boolean                    @default(false)
  instructions          String?
  createdAt             DateTime                   @default(now())
  updatedAt             DateTime                   @updatedAt
  createdById           String
  assignedById          String?
  classId               String
  generatedSet          Json?
  cqRequiredQuestions   Int?                       @default(5)
  cqTotalQuestions      Int?                       @default(8)
  mcqNegativeMarking    Float?                     @default(0)
  sqRequiredQuestions   Int?                       @default(5)
  sqTotalQuestions      Int?                       @default(15)
  cqSubsections         Json?
  mcNegativeMarking     Float?                     @default(0)
  mcPartialMarking      Boolean?                   @default(true)
  cqSqTime              Int?
  objectiveTime         Int?
  examSubmissions       ExamSubmission[]
  admitCards            AdmitCard[]
  evaluationAssignments ExamEvaluationAssignment[]
  examSets              ExamSet[]
  examStudentMaps       ExamStudentMap[]
  drawings              ExamSubmissionDrawing[]
  assignedBy            User?                      @relation("ExamAssigner", fields: [assignedById], references: [id])
  class                 Class                      @relation(fields: [classId], references: [id])
  createdBy             User                       @relation("ExamCreator", fields: [createdById], references: [id])
  omrSheets             OMRSheet[]
  resultReviews         ResultReview[]
  results               Result[]
  practiceResults       PracticeResult[]
  seatAllocations       SeatAllocation[]

  @@index([createdAt])
  @@index([classId])
  @@map("exams")
}

model Question {
  id                     String                   @id @default(cuid())
  type                   QuestionType
  subject                String
  questionText           String
  modelAnswer            String?
  tags                   String[]
  createdAt              DateTime                 @default(now())
  updatedAt              DateTime                 @updatedAt
  createdById            String
  clonedFromId           String?
  subQuestions           Json?
  isAiGenerated          Boolean                  @default(false)
  teacherProfileId       String?
  topic                  String?
  classId                String
  editedById             String?
  isPrivate              Boolean                  @default(false)
  lastEditedAt           DateTime?
  marks                  Int
  usageCount             Int                      @default(0)
  options                Json?
  difficulty             Difficulty
  hasMath                Boolean                  @default(false)
  images                 String[]
  isForPractice          Boolean                  @default(false)
  assertion              String?
  correctOption          Int?
  leftColumn             Json?
  matches                Json?
  reason                 String?
  rightColumn            Json?
  explanation            String?
  versions               QuestionVersion[]        @relation("QuestionVersions")
  QuestionToQuestionBank QuestionToQuestionBank[]
  class                  Class                    @relation("ClassQuestions", fields: [classId], references: [id])
  clonedFrom             Question?                @relation("ClonedQuestion", fields: [clonedFromId], references: [id], onUpdate: NoAction)
  clones                 Question[]               @relation("ClonedQuestion")
  createdBy              User                     @relation(fields: [createdById], references: [id])
  editedBy               User?                    @relation("EditedQuestions", fields: [editedById], references: [id])
  TeacherProfile         TeacherProfile?          @relation("TeacherQuestions", fields: [teacherProfileId], references: [id])
  examSets               ExamSet[]                @relation("ExamSetToQuestion")

  @@index([type])
  @@index([subject])
  @@index([difficulty])
  @@index([topic])
  @@index([hasMath])
  @@index([createdAt])
  @@index([createdById])
  @@index([classId])
  @@map("questions")
}

model QuestionBank {
  id                     String                   @id @default(cuid())
  name                   String
  description            String?
  subject                String
  chapter                String?
  isActive               Boolean                  @default(true)
  createdAt              DateTime                 @default(now())
  updatedAt              DateTime                 @updatedAt
  createdById            String
  teacherId              String?
  QuestionToQuestionBank QuestionToQuestionBank[]
  createdBy              User                     @relation(fields: [createdById], references: [id])
  teacher                TeacherProfile?          @relation("TeacherQuestionBanks", fields: [teacherId], references: [id])
  examSets               ExamSet[]                @relation("ExamSetToQuestionBank")

  @@map("question_banks")
}

model ExamSet {
  id              String           @id @default(cuid())
  name            String
  description     String?
  isActive        Boolean          @default(true)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  createdById     String
  examId          String
  questionsJson   Json?
  examSubmissions ExamSubmission[]
  createdBy       User             @relation(fields: [createdById], references: [id])
  exam            Exam             @relation(fields: [examId], references: [id], onDelete: Cascade)
  examStudentMaps ExamStudentMap[]
  omrSheets       OMRSheet[]
  questions       Question[]       @relation("ExamSetToQuestion")
  questionBanks   QuestionBank[]   @relation("ExamSetToQuestionBank")

  @@unique([name, examId])
  @@map("exam_sets")
}

model ExamStudentMap {
  id        String         @id @default(cuid())
  isActive  Boolean        @default(true)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  studentId String
  examId    String
  examSetId String?
  exam      Exam           @relation(fields: [examId], references: [id], onDelete: Cascade)
  examSet   ExamSet?       @relation(fields: [examSetId], references: [id])
  student   StudentProfile @relation(fields: [studentId], references: [id])

  @@unique([studentId, examId])
  @@map("exam_student_maps")
}

model OMRSheet {
  id            String          @id @default(cuid())
  qrCode        String          @unique
  scannedData   Json?
  resultData    Json?
  isProcessed   Boolean         @default(false)
  scanSessionId String?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  studentId     String
  examId        String
  examSetId     String?
  exam          Exam            @relation(fields: [examId], references: [id], onDelete: Cascade)
  examSet       ExamSet?        @relation(fields: [examSetId], references: [id])
  scanSession   OMRScanSession? @relation(fields: [scanSessionId], references: [id])
  student       StudentProfile  @relation(fields: [studentId], references: [id])

  @@unique([studentId, examId, examSetId])
  @@map("omr_sheets")
}

model AdmitCard {
  id           String         @id @default(cuid())
  qrCode       String         @unique
  examCenter   String?
  roomNumber   String?
  seatNumber   String?
  instructions String?
  isPrinted    Boolean        @default(false)
  printedAt    DateTime?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  studentId    String
  examId       String
  exam         Exam           @relation(fields: [examId], references: [id])
  student      StudentProfile @relation(fields: [studentId], references: [id])

  @@unique([studentId, examId])
  @@index([qrCode])
  @@map("admit_cards")
}

model Attendance {
  id        String   @id @default(cuid())
  date      DateTime
  present   String[]
  absent    String[]
  late      String[]
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  teacherId String
  classId   String
  class     Class    @relation(fields: [classId], references: [id])
  teacher   User     @relation("AttendanceTeacher", fields: [teacherId], references: [id])

  @@unique([date, classId])
  @@map("attendance")
}

model Result {
  id               String          @id @default(cuid())
  mcqMarks         Float           @default(0)
  cqMarks          Float           @default(0)
  total            Float           @default(0)
  rank             Int?
  grade            String?
  percentage       Float?
  comment          String?
  isPublished      Boolean         @default(false)
  publishedAt      DateTime?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  examSubmissionId String?         @unique
  sqMarks          Float           @default(0)
  examId           String
  studentId        String
  exam             Exam            @relation(fields: [examId], references: [id], onDelete: Cascade)
  examSubmission   ExamSubmission? @relation(fields: [examSubmissionId], references: [id], onDelete: Cascade)
  student          StudentProfile  @relation(fields: [studentId], references: [id])

  @@unique([studentId, examId])
  @@index([examId])
  @@map("results")
}

model Badge {
  id          String         @id @default(cuid())
  title       String
  type        BadgeType
  description String?
  condition   String?
  issuedDate  DateTime       @default(now())
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  earnedById  String
  studentId   String
  earnedBy    User           @relation("UserBadges", fields: [earnedById], references: [id])
  student     StudentProfile @relation("StudentBadges", fields: [studentId], references: [id])

  @@map("badges")
}

model Notice {
  id             String          @id @default(cuid())
  title          String
  description    String
  targetClassIds String[]
  targetType     NoticeTarget
  priority       NoticePriority  @default(MEDIUM)
  category       String?         @default("General")
  links          Json?           // Array of { label: string, url: string }
  attachments    Json?           // Array of { name: string, url: string }
  readBy         String[]        // Array of user IDs who have read this notice
  isActive       Boolean         @default(true)
  expiresAt      DateTime?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  postedById     String
  postedBy       User            @relation(fields: [postedById], references: [id])
  targetClasses  Class[]         @relation("NoticeToClasses")

  @@index([priority])
  @@index([createdAt])
  @@index([targetType])
  @@index([isActive])
  @@index([expiresAt])
  @@map("notices")
}

model AIActivity {
  id           String   @id @default(cuid())
  activityType String
  usageCount   Int      @default(1)
  tokenCost    Float?
  responseTime Int?
  success      Boolean  @default(true)
  errorMessage String?
  metadata     Json?
  createdAt    DateTime @default(now())
  userId       String
  user         User     @relation(fields: [userId], references: [id])

  @@index([createdAt])
  @@index([userId])
  @@map("ai_activities")
}

model Log {
  id        String     @id @default(cuid())
  action    ActionType
  context   Json?
  ipAddress String?
  userAgent String?
  timestamp DateTime   @default(now())
  userId    String
  user      User       @relation(fields: [userId], references: [id])

  @@index([timestamp])
  @@index([action])
  @@index([userId])
  @@map("logs")
}

model Settings {
  id              String    @id @default(cuid())
  instituteName   String
  logoUrl         String?
  signatureUrl    String?
  colorTheme      Json?
  contactInfo     Json?
  features        Json?
  limits          Json?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  instituteId     String    @unique
  maintenanceMode Boolean   @default(false)
  institute       Institute @relation(fields: [instituteId], references: [id])

  @@map("settings")
}

model OMRScanSession {
  id             String     @id @default(cuid())
  sessionName    String
  examinerId     String
  filesUploaded  String[]
  failedFiles    String[]
  totalFiles     Int        @default(0)
  processedFiles Int        @default(0)
  isCompleted    Boolean    @default(false)
  completedAt    DateTime?
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  omrSheets      OMRSheet[]

  @@map("omr_scan_sessions")
}

model StripePlan {
  id          String    @id @default(cuid())
  planId      String    @unique
  name        String
  description String?
  price       Float
  currency    String    @default("USD")
  interval    String
  limits      Json?
  features    Json?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  billing     Billing[]

  @@map("stripe_plans")
}

model Billing {
  id                   String        @id @default(cuid())
  stripeCustomerId     String?
  stripeSubscriptionId String?
  status               BillingStatus @default(ACTIVE)
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  nextPaymentDue       DateTime?
  amount               Float?
  currency             String        @default("USD")
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt
  userId               String
  planId               String
  plan                 StripePlan    @relation(fields: [planId], references: [id])
  user                 User          @relation(fields: [userId], references: [id])

  @@map("billing")
}

model ExportJob {
  id            String          @id @default(cuid())
  type          ExportJobType
  status        ExportJobStatus @default(PENDING)
  downloadUrl   String?
  fileSize      Int?
  errorMessage  String?
  metadata      Json?
  startedAt     DateTime?
  completedAt   DateTime?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  triggeredById String
  triggeredBy   User            @relation(fields: [triggeredById], references: [id])

  @@index([createdAt])
  @@map("export_jobs")
}

model ChatSession {
  id        String        @id @default(cuid())
  title     String?
  isActive  Boolean       @default(true)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  userId    String
  messages  ChatMessage[]
  user      User          @relation(fields: [userId], references: [id])

  @@map("chat_sessions")
}

model ChatMessage {
  id         String      @id @default(cuid())
  prompt     String
  response   String
  tokensUsed Int?
  createdAt  DateTime    @default(now())
  sessionId  String
  session    ChatSession @relation(fields: [sessionId], references: [id])

  @@map("chat_messages")
}

model ActivityAudit {
  id        String   @id @default(cuid())
  date      DateTime
  module    String
  action    String
  count     Int      @default(0)
  metadata  Json?
  createdAt DateTime @default(now())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])

  @@unique([date, module, userId])
  @@index([date])
  @@index([module])
  @@map("activity_audits")
}

model QuestionVersion {
  id            String   @id @default(cuid())
  questionId    String
  versionNumber Int
  data          Json
  createdAt     DateTime @default(now())
  question      Question @relation("QuestionVersions", fields: [questionId], references: [id], onDelete: Cascade)
}

model QuestionToQuestionBank {
  A              String
  B              String
  questions      Question     @relation(fields: [A], references: [id], onDelete: Cascade)
  question_banks QuestionBank @relation(fields: [B], references: [id], onDelete: Cascade)

  @@id([A, B], map: "_QuestionToQuestionBank_AB_pkey")
  @@index([B], map: "_QuestionToQuestionBank_B_index")
  @@map("_QuestionToQuestionBank")
}

model ExamSubmission {
  id                    String                  @id @default(cuid())
  studentId             String
  examId                String
  answers               Json
  score                 Float?
  evaluatedAt           DateTime?
  evaluatorNotes        String?
  examSetId             String?
  exceededQuestionLimit Boolean                 @default(false)
  status                SubmissionStatus        @default(PENDING)
  cqSqStartedAt         DateTime?
  cqSqStatus            SubmissionStatus        @default(PENDING)
  cqSqSubmittedAt       DateTime?
  objectiveStartedAt    DateTime?
  objectiveStatus       SubmissionStatus        @default(PENDING)
  objectiveSubmittedAt  DateTime?
  exam                  Exam                    @relation(fields: [examId], references: [id], onDelete: Cascade)
  examSet               ExamSet?                @relation(fields: [examSetId], references: [id])
  student               StudentProfile          @relation(fields: [studentId], references: [id])
  drawings              ExamSubmissionDrawing[]
  resultReviews         ResultReview[]
  result                Result?

  @@unique([studentId, examId])
  @@index([status])
  @@index([score])
  @@index([examId])
}

model ExamSubmissionDrawing {
  id                String         @id @default(cuid())
  studentId         String
  questionId        String
  examId            String
  imageData         String
  originalImagePath String
  evaluatorId       String
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  imageIndex        Int            @default(0)
  evaluator         User           @relation(fields: [evaluatorId], references: [id])
  exam              Exam           @relation(fields: [examId], references: [id], onDelete: Cascade)
  submission        ExamSubmission @relation(fields: [studentId, examId], references: [studentId, examId], onDelete: Cascade)
  student           StudentProfile @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@unique([studentId, questionId, imageIndex])
  @@map("exam_submission_drawings")
}

model ExamEvaluationAssignment {
  id           String           @id @default(cuid())
  examId       String
  evaluatorId  String
  assignedById String
  assignedAt   DateTime         @default(now())
  status       EvaluationStatus @default(PENDING)
  notes        String?
  completedAt  DateTime?
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  assignedBy   User             @relation("ExamAssignmentCreator", fields: [assignedById], references: [id])
  evaluator    User             @relation("ExamEvaluator", fields: [evaluatorId], references: [id])
  exam         Exam             @relation(fields: [examId], references: [id], onDelete: Cascade)

  @@unique([examId, evaluatorId])
  @@map("exam_evaluation_assignments")
}

model ResultReview {
  id               String         @id @default(cuid())
  examId           String
  studentId        String
  studentComment   String
  evaluatorComment String?
  status           ReviewStatus   @default(PENDING)
  requestedAt      DateTime       @default(now())
  reviewedAt       DateTime?
  reviewedById     String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  examSubmissionId String
  exam             Exam           @relation(fields: [examId], references: [id], onDelete: Cascade)
  examSubmission   ExamSubmission @relation(fields: [examSubmissionId], references: [id], onDelete: Cascade)
  reviewer         User?          @relation("ResultReviewer", fields: [reviewedById], references: [id])
  student          StudentProfile @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@unique([examId, studentId])
  @@map("result_reviews")
}

model ExamHall {
  id            String           @id @default(cuid())
  name          String
  roomNo        String?
  capacity      Int
  rows          Int              @default(5)
  columns       Int              @default(4)
  seatsPerBench Int              @default(2)
  instituteId   String
  institute     Institute        @relation(fields: [instituteId], references: [id])
  allocations   SeatAllocation[]

  @@map("exam_halls")
}

model SeatAllocation {
  id        String         @id @default(cuid())
  examId    String
  studentId String
  hallId    String
  seatLabel String
  exam      Exam           @relation(fields: [examId], references: [id])
  hall      ExamHall       @relation(fields: [hallId], references: [id])
  student   StudentProfile @relation(fields: [studentId], references: [id])

  @@unique([examId, studentId])
  @@index([examId, hallId])
  @@map("seat_allocations")
}

model PracticeResult {
  id               String          @id @default(cuid())
  studentId        String
  examId           String
  answers          Json            // Store student answers
  score            Float           @default(0)
  totalMarks       Int
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  student          StudentProfile  @relation(fields: [studentId], references: [id])
  exam             Exam            @relation(fields: [examId], references: [id], onDelete: Cascade)

  @@index([examId])
  @@index([studentId])
  @@map("practice_results")
}

model Notification {
  id          String           @id @default(cuid())
  userId      String
  title       String
  message     String
  type        NotificationType @default(INFO)
  isRead      Boolean          @default(false)
  relatedId   String?
  relatedType String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@map("notifications")
}

model AdmissionApplication {
  id                  String          @id @default(cuid())
  applicationNo       String          @unique
  studentName         String
  dateOfBirth         DateTime
  gender              String
  bloodGroup          String?
  photo               String?
  fatherName          String
  motherName          String
  guardianPhone       String
  guardianEmail       String?
  address             String
  previousSchool      String?
  previousClass       String?
  previousGPA         Float?
  applyingForClass    String
  applyingForClassId  String?
  birthCertificate    String?
  previousMarksheet   String?
  transferCertificate String?
  status              AdmissionStatus @default(PENDING)
  appliedAt           DateTime        @default(now())
  reviewedAt          DateTime?
  reviewedBy          String?
  testScore           Float?
  testDate            DateTime?
  admittedAt          DateTime?
  studentId           String?         @unique
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  class               Class?          @relation(fields: [applyingForClassId], references: [id])
  reviewer            User?           @relation("AdmissionReviewer", fields: [reviewedBy], references: [id])
  student             StudentProfile? @relation(fields: [studentId], references: [id])

  @@index([status])
  @@index([appliedAt])
  @@map("admission_applications")
}

model FeeStructure {
  id              String       @id @default(cuid())
  name            String
  classId         String
  tuitionFee      Float        @default(0)
  admissionFee    Float        @default(0)
  examFee         Float        @default(0)
  libraryFee      Float        @default(0)
  labFee          Float        @default(0)
  sportsFee       Float        @default(0)
  transportFee    Float        @default(0)
  otherFees       Float        @default(0)
  totalAmount     Float
  frequency       FeeFrequency @default(ANNUAL)
  dueDay          Int?
  siblingDiscount Float        @default(0)
  meritDiscount   Float        @default(0)
  active          Boolean      @default(true)
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  class           Class        @relation(fields: [classId], references: [id])
  invoices        Invoice[]

  @@map("fee_structures")
}

model Invoice {
  id              String         @id @default(cuid())
  invoiceNumber   String         @unique
  studentId       String
  feeStructureId  String
  subtotal        Float
  discount        Float          @default(0)
  lateFee         Float          @default(0)
  totalAmount     Float
  paidAmount      Float          @default(0)
  balanceAmount   Float
  issueDate       DateTime       @default(now())
  dueDate         DateTime
  status          InvoiceStatus  @default(PENDING)
  qrCode          String         @unique
  verificationUrl String
  notes           String?
  createdBy       String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  creator         User?          @relation("InvoiceCreator", fields: [createdBy], references: [id])
  feeStructure    FeeStructure   @relation(fields: [feeStructureId], references: [id])
  student         StudentProfile @relation(fields: [studentId], references: [id])
  payments        Payment[]

  @@index([status])
  @@index([studentId])
  @@index([dueDate])
  @@map("invoices")
}

model Payment {
  id              String        @id @default(cuid())
  receiptNumber   String        @unique
  invoiceId       String
  amount          Float
  paymentMethod   PaymentMethod
  paymentDate     DateTime      @default(now())
  transactionId   String?
  bankReference   String?
  status          PaymentStatus @default(COMPLETED)
  qrCode          String        @unique
  verificationUrl String
  notes           String?
  collectedBy     String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  collector       User?         @relation("PaymentCollector", fields: [collectedBy], references: [id])
  invoice         Invoice       @relation(fields: [invoiceId], references: [id])

  @@index([paymentDate])
  @@index([invoiceId])
  @@map("payments")
}

model VerifiableDocument {
  id              String       @id @default(cuid())
  documentType    DocumentType
  documentNumber  String       @unique
  referenceId     String
  referenceType   String
  qrHash          String       @unique
  verificationUrl String
  issuedDate      DateTime     @default(now())
  expiryDate      DateTime?
  isValid         Boolean      @default(true)
  revokedAt       DateTime?
  revokedBy       String?
  metadata        Json?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  @@index([qrHash])
  @@index([documentNumber])
  @@map("verifiable_documents")
}

enum Role {
  ADMIN
  TEACHER
  STUDENT
  SUPER_USER
}

enum QuestionType {
  MCQ
  CQ
  SQ
  MC
  INT
  AR
  MTF
  SMCQ
  DESCRIPTIVE
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
}

enum ExamType {
  ONLINE
  OFFLINE
  MIXED
}

enum BadgeType {
  ACHIEVEMENT
  PARTICIPATION
  EXCELLENCE
  MILESTONE
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  LATE
  EXCUSED
}

enum NoticeTarget {
  ALL
  STUDENTS
  TEACHERS
  ADMINS
  TEACHERS_AND_ADMINS
  SPECIFIC_CLASS
}

enum NoticePriority {
  URGENT
  HIGH
  MEDIUM
  LOW
}

enum ActionType {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  EXAM_START
  EXAM_SUBMIT
  OMR_SCAN
  CQ_EVALUATE
  AI_GENERATE
  EXPORT
  PRINT
}

enum ExportJobType {
  PDF
  CSV
  EXCEL
}

enum ExportJobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum BillingStatus {
  ACTIVE
  EXPIRED
  CANCELLED
  PENDING
}

enum EvaluationStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  APPROVED
  REJECTED
}

enum ReviewStatus {
  PENDING
  UNDER_REVIEW
  APPROVED
  REJECTED
  COMPLETED
}

enum NotificationType {
  INFO
  SUCCESS
  WARNING
  ERROR
  REVIEW_RESPONSE
}

enum SubmissionStatus {
  IN_PROGRESS
  SUBMITTED
  PENDING
}

enum QuestionStatus {
  APPROVED
  NEEDS_REVIEW
  DRAFT
}

enum AdmissionStatus {
  PENDING
  UNDER_REVIEW
  TEST_SCHEDULED
  TEST_COMPLETED
  ACCEPTED
  REJECTED
  ADMITTED
}

enum FeeFrequency {
  MONTHLY
  QUARTERLY
  HALF_YEARLY
  ANNUAL
  ONE_TIME
}

enum InvoiceStatus {
  PENDING
  PARTIALLY_PAID
  PAID
  OVERDUE
  CANCELLED
}

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  CHEQUE
  ONLINE
  CARD
  UPI
  MOBILE_BANKING
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum DocumentType {
  INVOICE
  RECEIPT
  CERTIFICATE
  ADMIT_CARD
  ID_CARD
  TRANSFER_CERTIFICATE
  ADMISSION_LETTER
}
